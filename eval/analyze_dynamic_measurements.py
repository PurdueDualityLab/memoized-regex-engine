# -*- coding: utf-8 -*-
"""analyze-dynamic-measurements.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mJXd9m8WCo-N5dh-hhbh4OhvbTvewIl4

# Mount your drive to access data
"""

try:
  import google.colab
  IN_COLAB = True
except:
  IN_COLAB = False

if IN_COLAB:
  from google.colab import drive
  drive.mount('/content/gdrive')

"""# Dynamic analyses for the Regex Optimization project

### Imports
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import json
import re
import itertools
import pandas as pd
import numpy as np
import scipy.stats as stats
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.transforms as transforms

sns.set_style('whitegrid')
# %matplotlib inline

pd.set_option('display.max_columns', 30)

"""## Globals"""

ANALYSIS_ROOT_GOOGLE = os.path.join(os.sep, 'content', 'gdrive', 'Shared drives', 'Regexes and REDOS', 'Memoization')

if IN_COLAB:
  ANALYSIS_ROOT = ANALYSIS_ROOT_GOOGLE
else:
  ANALYSIS_ROOT = '' # Must run in the right directory

DATA_PATH = os.path.join(ANALYSIS_ROOT, 'data')
FIG_PATH = os.path.join(ANALYSIS_ROOT, 'figs')
FIG_FILE_FORMAT = 'pdf'

# Create fig directory structure
try:
  os.mkdir(os.path.join(FIG_PATH))
except:
  pass

measure2name = {
    'full memoization':   r'$Q$',
    'selective: indeg>1': r'$Q_{in-deg > 1}$',
    'selective: loop':    r'$Q_{ancestor}$',
}

"""## Load data"""

def loadDF(filepath):
  if os.path.isdir(filepath):
    return mergeDFs(filepath)
  return pd.read_pickle(filepath)

def mergeDFs(splitDir):
  files = os.listdir(splitDir)
  filepaths = [os.path.join(splitDir, f) for f in files]
  first, rest = filepaths[0], filepaths[1:]
  df = pd.read_pickle(first)
  print("{} rows in {}".format(len(df), first))
  for f in rest:
    _df = pd.read_pickle(f)
    print("{} rows in {}".format(len(_df), f))
    df = df.append(_df)
  return df
            

#######
#######
#######
slFile = os.path.join(DATA_PATH, 'export-060220-1')
slFile = os.path.join(DATA_PATH, 'export-060220-2')
slFile = '/users/jamiedavis/Downloads/x.pkl.bz2'
slFile = os.path.join(DATA_PATH, 'exp-092920')
slFile = os.path.join(DATA_PATH, 'exp-093020')

slDF = loadDF(slFile)
uniqRegexes = slDF['pattern'].unique()
#allReg = loadNDJSON(allFile)
print('Loaded measurements for %d SL regexes' % (len(uniqRegexes)))
print('Columns: %s' % (list(slDF.columns)))
print(uniqRegexes)

"""## Munge DF"""

# Add appropriate columns for plotting

spaceCostColName = 'Proportion of full space cost'
slDF[spaceCostColName] = -1

# Calculate relative space cost by slices
index = slDF['selectionPolicy'] == "full memoization"
slDF.loc[ index, spaceCostColName ] = \
  slDF[index]['spaceCostAlgo'] / (slDF[index]['|Q|'] * slDF[index]['|w|'])

index = slDF['selectionPolicy'] == "selective: indeg>1"
slDF.loc[ index, spaceCostColName ] = \
  slDF[index]['spaceCostAlgo'] / (slDF[index]['|Q|'] * slDF[index]['|w|'])
  # slDF[index]['spaceCost'] / (slDF[index]['|Phi_{in-deg > 1}|'] * slDF[index]['|w|'])
  
index = slDF['selectionPolicy'] == "selective: loop"
slDF.loc[ index, spaceCostColName ] = \
  slDF[index]['spaceCostAlgo'] / (slDF[index]['|Q|'] * slDF[index]['|w|'])
  #slDF[index]['spaceCost'] / (slDF[index]['|Phi_{ancestor}|'] * slDF[index]['|w|'])

# Print some info and assert some facts
# TODO: Confirm that RLE shows badly??
print(slDF['selectionPolicy'].unique())
print(slDF[ slDF["encodingPolicy"] == "RLE" ][spaceCostColName].describe())
print(slDF.head(9))
print(slDF.tail(9))
assert slDF[spaceCostColName].max() <= 1, "Error, max is too high"
if False:
  assert 0 <= slDF[spaceCostColName].min(), "Error, min is too low"

"""## Cleanup for plotting"""

# Replace cell values that are shorthand with the consistent names
slDF.loc[slDF['selectionPolicy'] == "full memoization","selectionPolicy"] = r"$Q$"
slDF.loc[slDF['selectionPolicy'] == "selective: indeg>1","selectionPolicy"] = r"$Q_{in-deg > 1}$"
slDF.loc[slDF['selectionPolicy'] == "selective: loop","selectionPolicy"] = r"$Q_{ancestor}$"

slDF.loc[slDF['encodingPolicy'] == "negative encoding","encodingPolicy"] = r"Positive (hash)"
slDF.loc[slDF['encodingPolicy'] == "no encoding","encodingPolicy"] = r"No encoding (memo table)"

# Better column names for legend
slDF["Encoding policy"] = slDF["encodingPolicy"]

"""## Plot and analysis

### Comparison of language defenses
"""

# One row for each pattern
firsts = slDF.groupby(['pattern']).first()

if False:
  # Summarize by language
  langCols = ["perlBehavior", "phpBehavior", "csharpBehavior"]
  for col in langCols:
    print("{}\t\tcount".format(col))
    print("--------------\t\t-----")
    print(firsts[col].value_counts())
    print("\n********\n")

"""### Prototype performance"""

font = {'family' : 'normal',
        'weight' : 'normal',
        'size'   : 14}
matplotlib.rc('font', **font)
matplotlib.rc('text.latex', preamble=r'\usepackage{sfmath}')
matplotlib.rc('mathtext', fontset='stix')

print("\n********\n")
print('slDF results (space bytes) grouped by encoding policy')
print('\n')
print(slDF.groupby(['Encoding policy', 'selectionPolicy'])['spaceCostBytes'].describe(percentiles=[0.01, 0.05, 0.1, .25, .5, .75, 0.8, 0.85, 0.87, 0.89, 0.9, 0.95, 0.99]))
print('\n')
print("\n********\n")

print("\n********\n")
print('slDF results (algo cxty) grouped by encoding policy')
print('\n')
print(slDF.groupby(['Encoding policy', 'selectionPolicy'])['spaceCostAlgo'].describe(percentiles=[0.01, 0.05, 0.1, .25, .5, .75, 0.8, 0.85, 0.87, 0.89, 0.9, 0.95, 0.99]))
print('\n')
print("\n********\n")

plt.figure(1,
           figsize=(8,11)
           )
rawSpacePlt_whis = [5,90]
rawSpacePlt_showfliers = True
rawSpacePlt_fname = os.path.join(FIG_PATH, 'raw-space-cost-whis{}-{}-fliers{}.{}'.format(
    rawSpacePlt_whis[0], rawSpacePlt_whis[1], rawSpacePlt_showfliers, FIG_FILE_FORMAT))
ax = sns.boxplot(x="selectionPolicy", y="spaceCostBytes", hue="Encoding policy",
                 data=slDF[
                    (slDF['Encoding policy'] != "RLE-tuned") # Not a success story
                  ], 
                 order=[r'$Q$', r'$Q_{in-deg > 1}$', r'$Q_{ancestor}$'],
                 hue_order=['No encoding (memo table)', 'Positive (hash)', 'RLE'],
                 #width=1.0,
                 whis=rawSpacePlt_whis, showfliers=rawSpacePlt_showfliers, fliersize=2
                 )
kb = ax.axhline(1024, color='black', linestyle='--')
plt.text(-0.5, 1024 + 250, '1 KB', fontstyle='italic', fontsize=14)

mb = ax.axhline(1024*1024, color='black', linestyle='--')
plt.text(-0.5, 1024*1024 + 250000, '1 MB', fontstyle='italic', fontsize=13.5)

mb = ax.axhline(1024*1024*1024, color='black', linestyle='--')
plt.text(-0.5, 1024*1024*1024 + 95000000, '1 GB', fontstyle='italic', fontsize=14)

ax.set_yscale("log")
plt.ylim(bottom=75, top=7e9) # Max is about 6e9
plt.title(r'Space cost for Stack Overflow scenario', fontsize=20)
plt.xticks(fontsize=22)
plt.xlabel("")#"Selection scheme")
plt.yticks(fontsize=20)
#locs, labels = plt.yticks()
#plt.yticks(locs, [], **kwargs)
plt.ylabel("Space cost (bytes)", fontsize=15)
leg = ax.legend(
    loc='upper right',
    framealpha=0.45,
    #bbox_to_anchor= (0.52, 0.86), ncol=1,
    borderaxespad=0, 
    frameon=True,
    title='Encoding scheme',
    prop={'size': 13},
)
leg.set_title("Encoding scheme", prop = {'size': 16})
#plt.tight_layout()
print("Saving to {}".format(rawSpacePlt_fname))
plt.savefig(fname=rawSpacePlt_fname, bbox_inches='tight')

########################################################################

plt.figure(2)
ratioSpacePlt_whis = [1,99]
ratioSpacePlt_showfliers = True
ratioSpacePlt_fname = os.path.join(FIG_PATH, 'proportionate-space-cost-whis{}-{}-fliers{}.{}'.format(ratioSpacePlt_whis[0], ratioSpacePlt_whis[1], ratioSpacePlt_showfliers, FIG_FILE_FORMAT))
ax = sns.boxplot(x="selectionPolicy", y=spaceCostColName, hue="Encoding policy",
                 order=[r'$Q$', r'$Q_{in-deg > 1}$', r'$Q_{ancestor}$'],
                 hue_order=['Positive (hash)', 'RLE'],
                 data=slDF[
                    (slDF['Encoding policy'] != "No encoding (full table)") # Already captured by ratio
                    &
                    (slDF['Encoding policy'] != "RLE-tuned")], # Not a success story
                 #width=1.0,
                 whis=ratioSpacePlt_whis, showfliers=ratioSpacePlt_showfliers,
                 palette=sns.color_palette()[1:], # We omitted the bitmap costs, so don't use that color
                #, palette="Set3"
                 )
plt.title(r'Space costs relative to a $|Q| \times |w|$ table', fontsize=20)
plt.xlabel("Selection scheme")
plt.xticks(fontsize=20)
plt.yticks(fontsize=20)
#plt.legend(fontsize='small')
#plt.tight_layout()
ax.legend(
    #loc='lower left',
    #bbox_to_anchor= (1.05, 0.1), ncol=1,
    #borderaxespad=0, 
    #frameon=True,
    title='Encoding scheme',
)
print("Saving to {}".format(ratioSpacePlt_fname))
plt.savefig(fname=ratioSpacePlt_fname, bbox_inches='tight')

# plt.figure(2)
# ratiosPlt_whis = [1,99]
# ratiosPlt_showfliers = False
# ratiosPlt_fname = os.path.join(FIG_PATH, 'vertex-sizes-ratios-whis{}-{}-fliers{}.{}'.format(ratiosPlt_whis[0], ratiosPlt_whis[1], ratiosPlt_showfliers, FIG_FILE_FORMAT))
# ax = sns.boxplot(x="Measure", y="Value", hue=hue, data=dfRatios,
#                  #width=1.0,
#                  whis=ratiosPlt_whis, showfliers=ratiosPlt_showfliers,
#                  )
# plt.title('Space reduction via selective memoization', fontsize=20)
# plt.xticks(fontsize=24)
# plt.yticks(fontsize=16)
# plt.tight_layout()
# print("Saving to {}".format(ratiosPlt_fname))
# plt.savefig(fname=ratiosPlt_fname)

if False:
  """### Comparison to Perl's **protection**"""

  nPatterns = len( slDF['pattern'].unique())
  perlLinearPatterns = slDF[ ~slDF['perlTimedOut'] ]['pattern'].unique()
  nPerlLinearPatterns = len(perlLinearPatterns)
  print("Using memoization, all {} patterns met the time complexity guarantees appropriate to their selection scheme".format(nPatterns))
  print("{}/{} ({}%) patterns were linear-time in Perl; {}% were super-linear".format(nPerlLinearPatterns, nPatterns, int(100*nPerlLinearPatterns/nPatterns), int(100*(nPatterns-nPerlLinearPatterns)/nPatterns)))

"""### The relative costliness of RLE and RLE-TUNED"""

if False:
  selectionPolicies = [r'$Q_{in-deg > 1}$', r'$Q_{ancestor}$']

  # Pick a fairly arbitrary cost measure
  for selectionPolicy in selectionPolicies:
    print("Considering selectionPolicy {}".format(selectionPolicy))
    nPatterns = len(slDF['pattern'].unique())
    costThreshold = 1000
    rows = slDF[(slDF['encodingPolicy'] == 'RLE') &
                (slDF['selectionPolicy'] == selectionPolicy) &
                (slDF['spaceCostAlgo'] > costThreshold) ]
    print("{}/{} ({}%) were costly patterns for Phi_quant under RLE".format(len(rows), nPatterns, int(100*len(rows)/nPatterns)))
    
    #for p in rows['pattern']:
    #  print("Costly pattern: /{}/".format(p))
    
    # Which became more costly?
    print(slDF.columns)
    print(slDF.head(12))
    pattern2costs = {}
    anyItem = None
    # TODO This should be a groupby...
    print("Building pattern2costs by, ahem, iterating over the DF")
    for i, row in slDF.iterrows():
      if row['pattern'] not in pattern2costs:
        pattern2costs[row['pattern']] = { 'pattern': row['pattern'] }
      if row['selectionPolicy'] == selectionPolicy and row['encodingPolicy'] == 'RLE':
        pattern2costs[row['pattern']]['spaceCost-RLE'] = row['spaceCostAlgo']
        anyItem = pattern2costs[row['pattern']]
      elif row['selectionPolicy'] == selectionPolicy and row['encodingPolicy'] == 'RLE-tuned':
        pattern2costs[row['pattern']]['spaceCost-RLE-tuned'] = row['spaceCostAlgo']
        anyItem = pattern2costs[row['pattern']]
    
    print("\n\n*******\n\nDescribing the space costs for RLE under the {} scheme\n\n********\n\n".format(selectionPolicy))
    compDF = pd.DataFrame(columns=anyItem.keys(), data=pattern2costs.values())
    print(compDF.columns)
    print(compDF.describe(percentiles=[0.01, 0.05, 0.1, .25, .5, .75, 0.9, 0.95, 0.99]))
